name: Send Onsen Banner Email

on:
  # 매일 00:00 UTC = 09:00 KST
  schedule:
    - cron: "0 0 * * *"
  workflow_dispatch: {}

jobs:
  run-and-email:
    runs-on: ubuntu-latest
    env:
      SMTP_HOST: smtp.gmail.com
      SMTP_PORT: "465"
      SMTP_USER: ${{ secrets.SMTP_USER }}
      SMTP_PASS: ${{ secrets.SMTP_PASS }}
      MAIL_TO:   ${{ secrets.MAIL_TO }}
      MAIL_FROM: ${{ secrets.MAIL_FROM }}

    steps:
      - name: Check out repo
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          python -m pip install requests beautifulsoup4 lxml charset-normalizer chardet

      - name: Run banner fetch + send email
        run: |
          python - <<'PYCODE'
          import os, re, ssl, smtplib, requests
          from bs4 import BeautifulSoup
          from email.mime.text import MIMEText  # type: ignore

          URL = "https://www.onsen.co.nz/experiences/"
          UA  = ("Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 "
                 "(KHTML, like Gecko) Chrome/124.0 Safari/537.36")
                 
          CANDIDATE_SELECTORS = [
              '[class*="banner"]','[class*="marquee"]','[class*="ticker"]',
              '[class*="notice"]','[class*="announcement"]','[data-component*="banner"]',
              'footer'
          ]
          HINT_KEYWORDS = [
              "availability","cancellation","cancellations","released",
              "until","up until","live system","booking","sold out",
          ]

          def collapse_ws(s: str) -> str:
              import re
              return re.sub(r"\s+", " ", s or "").strip()

          def looks_like_cookie(t: str) -> bool:
              t = t.lower()
              return any(x in t for x in ("cookie", "consent", "privacy", "analytics"))

          def extract_banner_texts(soup):
              candidates = []
              for sel in CANDIDATE_SELECTORS:
                  for node in soup.select(sel):
                      txt = collapse_ws(node.get_text(" ", strip=True))
                      if not txt: continue
                      if looks_like_cookie(txt): continue
                      if len(txt) < 25: continue
                      candidates.append(txt)

              def score(t):
                  tl = t.lower()
                  return sum(1 for k in HINT_KEYWORDS if k in tl)

              # 중복 제거
              uniq, seen = [], set()
              for t in candidates:
                  key = t.lower()
                  if key not in seen:
                      seen.add(key)
                      uniq.append(t)

              # 힌트 점수로 정렬 (preview와 동일한 순서 정책)
              uniq.sort(key=score, reverse=True)
              return uniq

          def get_shortest_banner():
              r = requests.get(URL, headers={"User-Agent": UA}, timeout=20)
              r.raise_for_status()
              texts = extract_banner_texts(r.text)
              if not texts:
                  return "※ 배너 텍스트를 찾지 못했습니다."
              texts.sort(key=len)   # [2]에 해당하는 짧은 문구 선택
              return texts[0]
              
          def get_first_banner():
              r = requests.get(URL, headers={"User-Agent": UA}, timeout=20)
              r.raise_for_status()
              texts = extract_banner_texts(r.text)
              if not texts:
                  return "※ 배너 텍스트를 찾지 못했습니다."
              if len(texts) >= 1:
                  return texts[0]   # ✅ [1] 번째 항목
              
          def get_second_banner():
              r = requests.get(URL, headers={"User-Agent": UA}, timeout=20)
              r.raise_for_status()
              soup = BeautifulSoup(r.text, "lxml")
              texts = extract_banner_texts(soup)
              if not texts:
                  return "※ 배너 텍스트를 찾지 못했습니다."
              if len(texts) >= 2:
                  return texts[1]   # ✅ [2] 번째 항목
              return texts[0]       # 후보가 하나뿐이면 1번째라도 전송

          def send_email(subject: str, body: str):
              host = os.environ["SMTP_HOST"]
              port = int(os.environ["SMTP_PORT"])
              user = os.environ["SMTP_USER"]
              pw   = os.environ["SMTP_PASS"]
              mail_from = os.environ.get("MAIL_FROM", user)
              mail_to   = os.environ["MAIL_TO"]

              msg = MIMEText(body, _charset="utf-8")
              msg["Subject"] = subject
              msg["From"] = mail_from
              msg["To"] = mail_to

              ctx = ssl.create_default_context()
              with smtplib.SMTP_SSL(host, port, context=ctx, timeout=30) as server:
                  server.login(user, pw)
                  server.send_message(msg)
          banner1 = get_first_banner()
          banner2 = get_second_banner()
          subject = "오늘의 Onsen 배너"
          body = f"{banner1}\n\n{banner2}\n\n(출처: {URL})"
          send_email(subject, body)
          print("Email sent with banner:", banner1)
          print("Email sent with banner:", banner2)
          PYCODE
